#!/usr/bin/env python3
"""
Tool handling the upload of packages to a repository
"""
# pylint: disable=wrong-import-position
# pylint: disable=invalid-name

import signal
import sys
import time
import os
from argparse import ArgumentParser, RawDescriptionHelpFormatter
from typing import Tuple

import yaml

from watchdog.events import PatternMatchingEventHandler
from watchdog.observers import Observer


PRIVATE_SCRIPT_DIR = os.path.relpath(r'@pkgdatadir@', r'@bindir@')  # pylint: disable=line-too-long
CURR_DIR = os.path.abspath(os.path.dirname(__file__))
ABS_SCRIPT_DIR = os.path.abspath(os.path.join(CURR_DIR, PRIVATE_SCRIPT_DIR))
sys.path.insert(0, ABS_SCRIPT_DIR)
from repo import Repo  # noqa


# configuration global variable
OBSERVERS = []

class MmpackDbObserver(PatternMatchingEventHandler):
    """
    Observer to update repository

    Listen for the upload of a mmpack-manifest file.
    On apparition of such a file, check that the manifest and data received are
    coherent. If this is the case then proceed the update of the repository,
    otherwise abort the upload (meaning suppress the residual files: the files
    uploaded by the user and the directory created to deal with the data).
    """
    patterns = ['*.mmpack-manifest']

    def __init__(self, to_observe, repo: Repo):
        super().__init__()
        self.to_observe = to_observe
        self.repo = repo

    def on_created(self, event):
        """
        creation callback
        """
        self.repo.try_handle_upload(event.src_path)


def cleanup_exit(sig=None, frame=None):
    """
    clean observers and exit
    """
    # pylint: disable=unused-argument
    for observer in OBSERVERS:
        observer.stop()
    exit(0)


def watch_folder_for_change(repo: Repo, to_observe: str):
    """
    entry point to update the repository
    """
    # watch folder for changes
    observer = Observer()
    observer.schedule(MmpackDbObserver(to_observe, repo),
                      to_observe, recursive=False)
    observer.start()
    OBSERVERS.append(observer)
    signal.signal(signal.SIGINT, cleanup_exit)

    # sleep until manual interrupt
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        cleanup_exit()


def batch_cmd_add(repo: Repo, manifest: str) -> Tuple[bool, str]:
    """
    Add packages listed in manifest to repository
    """
    if not manifest:
        return (False, 'missing argument')

    success = repo.try_handle_upload(manifest, remove_upload=False)
    if not success:
        return (False, 'adding manifest failed')

    return (success, '')


def batch_updates(repo: Repo):
    """
    Read stdin and perform repository update specified in each line
    This is useful to implement a repository update in a subprocess
    communicating over pipes.
    """
    for line in sys.stdin:
        cmdargs = line.split(maxsplit=1)
        if not cmdargs:
            continue

        if len(cmdargs) == 1:
            cmdargs.append('')

        cmd = cmdargs[0]
        args = cmdargs[1]

        if cmd == 'add':
            success, errmsg = batch_cmd_add(repo, args)
        else:
            success = False
            errmsg = 'unknown command'

        print('OK' if success else ('FAIL ' + errmsg), flush=True)


def load_repository(opts) -> Repo:
    """
    Load repository according to command line options
    """
    repo_path = opts.repo_path
    os.makedirs(repo_path, exist_ok=True)

    # Load metadata from repo or create if not existing
    metadata_path = os.path.join(repo_path, 'metadata')
    try:
        metadata = yaml.load(open(metadata_path, 'rt'), Loader=yaml.BaseLoader)
    except FileNotFoundError:
        #Â Create initial repo metadata if new repo
        if not opts.repo_arch:
            print('New repository must have architecture specified', file=sys.stderr)
            sys.exit(1)
        metadata = {'architecture': opts.repo_arch}
        yaml.dump(metadata, open(metadata_path, 'wt'), default_flow_style=False)

    repo_arch = metadata['architecture']
    return Repo(repo_path, repo_arch)


def parse_options():
    """
    parse options
    """
    parser = ArgumentParser(description=__doc__,
                            formatter_class=RawDescriptionHelpFormatter)

    parser.add_argument('-p', '--path', default='.',
                        action='store', dest='repo_path', type=str,
                        help='path to repository')
    parser.add_argument('-a', '--arch',
                        action='store', dest='repo_arch', type=str,
                        help='architecture of repository if created')

    subparsers = parser.add_subparsers(dest='cmd', required=True)

    # watch command parser
    watch_subparser = subparsers.add_parser('watch')
    watch_subparser.add_argument('to_observe',
                                 help='folder to watch for incoming manifest')

    # update command parser
    update_subparser = subparsers.add_parser('add')
    update_subparser.add_argument('manifest', help='manifest file')

    # batch command parser
    subparsers.add_parser('batch')

    return parser.parse_args()


def main() -> int:
    """
    main program entry
    """
    opts = parse_options()
    repo = load_repository(opts)
    success = True

    if opts.cmd == 'watch':
        watch_folder_for_change(repo, opts.to_observe)
    elif opts.cmd == 'add':
        success = repo.try_handle_upload(opts.manifest, remove_upload=False)
        print('manifest added' if success else 'update failed')
    elif opts.cmd == 'batch':
        batch_updates(repo)

    return 0 if success else 1


if __name__ == '__main__':
    sys.exit(main())
